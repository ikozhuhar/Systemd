### Systemd. Система инициализация в Linux.

#### <a name='toc'>Содержание</a>

1. [Система инициализации](#initialization_system)
2. [Управление сервисами при использовании systemd](#managing_services)
3. [Дополнительные источники](#recommended_sources)


#### 1. [[⬆]](#toc) <a name='initialization_system'>Система инициализации</a>

После своей загрузки ядро передает управление системе инициализации, Цель этой системы - выполнить дальнейшую инициализацию системы, 
> _**Самая главная задача системы инициалиэации - запуск и управление системными службами. Служба (сервис, демон) - специальная программа, выполняющаяся в фоновом режиме и предоставляющая определенные услуги (или, как говорят, сервис - отсюда и второе название).**_

**Systemd** - подсистема инициализации и управления службами в Linux. Основная особенность - интенсивное **распараллеливание** запуска служб в процессе загрузки системы, что позволяет существенно ускорить запуск операционной системы.

##### Принцип работы
Система инициализации systemd используется во многих современных дистрибутивах, и на данный момент это самая быстрая система инициализации. Например, upstart - запускает службы параллельно. Но параллельный запуск - не всегда хорошо. Нужно учитывать зависимости служб. Например, сервис d-bus нужен многим другим сервисам. Пока сервис d-bus не будет запушен, нельзя запускать сервисы, которые от него зависят. И если сервис d-bus (или любой другой, от которого зависят какие-то другие сервисы) запускается долго, то все остальные службы будут ждать его загрузки, что скажется на загрузки системы в целом.

В systemd все по другому. При своем запуске службы проверяют, запущена ли необходимая им служба, по наличию файла сокета. Например, в случае с d-bus это файл `/var/run/dbus/system_bus_socket`. Если создать сокеты для всех служб, то можно запускать их параллельно, особо не беспокоясь, что произойдет сбой какой-то службы при запуске из-за отсутствия службы, от которой они зависят. Даже если несколько служб, которым нужен сервис d-bus, запустятся раньше, чем сам сервис d-bus, ничего страшного. Каждая из этих служб отправит в сокет (главное, что он уже открыт!) сообщение, которое обработает сервис d-bus после того, как он запустится. Вот, собственно, и все.

##### Конфигурационные файлы systemd
Systemd запускает сервисы описанные в его конфигурации. Конфигурация состоит из множества файлов, которые называют юнитами или модулями. Все эти юниты/модули разложены в трех каталогах:

| Путь | Описание |
| ------- | ----------- |
| `/etc/systemd/system` | юниты/модули, которые создаёт администратор системы. Обладают самым высоким приоритетом.|
| `/run/systemd/system` | юниты/модули, которые создаются в процессе работы системы. Приоритет этого каталога ниже, чем каталога /etc/systemd/system/, но выше, чем у /usr/lib/systemd/system |
| `/usr/lib/systemd/system` | юниты/модули сервисов, установленных с помощью менеджера пакетов. Самый простой пример — веб-серверы: Apache или Nginx. |

Типичный файл модуля типа service  

![image](https://github.com/user-attachments/assets/0a56b4d5-3834-4be0-8e08-328dddbe27b5)

| Путь | Описание |
| ------- | ----------- |
| `[Unit]` | В секции `Unit` содержится общая информация о сервисе. Эта секция есть и в друrих модулях, а не только в сервисах. |
| `[Service]` | Секция `Service`содержит информацию о сервисе. Параметр `ExecStart` описывает команду, которую нужно запустить. Параметр `Туре` указывает, как сервис будет уведомлять systemd об окончании запуска. |
| `[Install]` | Секция Install содержит информацию о цели, в которой должен запускаться сервис. |

Таким образом можно создать собственный сервис, который потом нужно поместить в файл `/etc/systemd/systern/имя_сервиса. service`. После этого нужно перезапустить саму systemd, чтобы она узнала о новом сервисе:
```
sudo systemctl daemon-reload
```

##### Типы модулей системы инициализации systemd

| Тип | Описание |
| ------- | ----------- |
| `service` | Служба (сервис, демон), которую нужно запустить. Пример имени модуля: network.service. Изначально systemd поддерживала сценарии SysV (чтобы управлять сервисами можно service было как при использовании init), но в последнее время в каталоге /etc/init.d систем, которые используют systemd, практически пусто (или вообще пусто), а управление сервисами осуществляется только посредством systemd |
| `target` | Цель. Используется для группировки модулей других типов. В systemd нет уровней запуска, вместо них используются цели. Например, цель multi-user.target описывает, какие модули должны быть запущены в многопользовательском режиме |
| `snapshot` | Точка монтирования. Представляет точку монтирования. Система инициализации systemd контролирует все точки монтирования. При использовании systemd файл /etc/fstab уже не главный, хотя все еще может использоваться для определения точек монтирования |
| `automount` | Автоматическая точка монтирования. Используется для монтирования сменных носителей - флешек, внешних жестких дисков, оптических дисков и т.д. |
| `socket` | Сокет. Представляет сокет, находящийся в файловой системе или в Интернете. Поддерживаются сокеты AF_INET, AF_INET6, AF_UNIX. Реализация довольно интересная. Например, если сервису service1.service соответствует сокет service1.socket, то при попытке установки соединения с service1.socket будет запущен service1.service  |
| `device` | Устройство. Представляет устройство в дереве устройств. Работает вместе с udev: если устройство описано в виде правила udev, то его можно представить в systemd в виде модуля device |
| `path` | Файл или каталог, созданный где-то в файловой системе |
| `scope` | Процесс, который создан извне |
| `slice` | Управляет системными процессами. Представляет собой группу иерархически организованных модулей |
| `swap` | Представляет область подкачки (раздел подкачки) или файл подкачки (свопа) |
| `timer` | Представляет собой таймер системы инициализации systemd  |

##### Цели
Файлы целей systemd *.target предназначены для группировки вместе других юнитов systemd через цепочку зависимостей. Например юнит graphical.target, использующийся для старта графической сессии, запускает системные сервисы GNOME Display Manager (gdm.service) и Accounts Service (accounts–daemon.service) и активирует multi–user.target. В свою очередь multi–user.target запускает другие системные сервисы, такие как Network Manager (NetworkManager.service) или D-Bus (dbus.service) и активирует другие целевые юниты basic.target.

В systemd имеются предопределенные цели, которые напоминают стандартный набор уровней запуска. Некоторые цели называются runlevelN.target, чтобы упростить переход бывших пользователей init на systemd, а именно:

| Путь | Описание |
| ------- | ----------- |
| `poweroff.target (runlevelO.target)` | завершение работы и отключение системы |
| `rescue.target (runlevell .target)` | однопользовательский режим, среда восстановления |
| `multi-user.target (runlevel{2,3,4}.target)` | многопользовательский режим, без графического интерфейса |
| `graphical.target (runlevel5.target)` | многопользовательский режим с графическим интерфейсом |
| `reboot.target (runlevel6.target)` | завершение работы и перезагрузка системы |

Управление службами осуществляется с помощью программы systemctl. Например:

1. `systemctl start <uмя.service>` - запускает сервис
2. `systemctl stop <uмя.service>` - останавливает сервис
3. `systemctl restart <uмя.service>` - перезапускает сервис


#### 2. [[⬆]](#toc) <a name='managing_services'>Управление сервисами при использовании systemd</a>

В systemd целью большинства действий являются «юниты/модули», являющиеся ресурсами, которыми systemd знает, как управлять. Модули распределяются по категориям по типу ресурса, который они представляют, и определяются файлами, известными как файлы модулей. 

Systemd содержит инструмент `systemctl`, который позволяет управлять работой служб: запускать и останавливать, проверять состояние, обновлять конфигурацию и т.д.

##### Параметры программы systemctl

| Параметр | Описание |
| ------- | ----------- |
| `systemctl start <uмя.service>` | запускает сервис |
| `systemctl stop <uмя.service>` | останавливает сервис  |
| `systemctl restart <uмя.service>` | перезапускает сервис  |
| `systemctl try-restart <uмя.service>` | перезапуск сервиса, только если он запущен  |
| `systemctl reload <uмя.service>` | перезагружает конфигурацию сервиса  |
| `systemctl status <uмя.service>` | отображает подробное состояние сервиса |
| `systemctl is-active <uмя.service>` | отображает только строку active (сервис запущен) или inactive (остановлен) |
| `systemctl list-units --type service --all` | выводит состояние всех сервисов |
| `systemctl епаblе <uмя.service>` | включает сервис (обеспечивает его автоматический запуск) |
| `systemctl disable <uмя.service>` | отключает сервис (сервис не будет автоматически запускаться при запуске системы) |
| `systemctl rееnаblе <uмя.service>` | деактивирует сервис и сразу его нспользует |
| `systemctl list-unit-files --type service` | Выводит список всех сервисов и сообщает, какие из них активированы, а какие - нет |

Примеры:
```
sudo systemctl start httpd.service
sudo systemctl stop httpd
```

Первая команда запускает сервис httpd (веб-сервер), вторая - останавливает. Обратите внимание, что "`.service`" можно не указывать. Раньше, чтобы отключить службу на определенном уровне запуска, нужно было удалить ее символическую ссьшку из определенного каталога. Аналогично, чтобы служба запускалась на определенном уровне запуска (например, в графическом режцме), нужно бьшо создать символическую ссьшку. Сейчас всего этого нет, а есть только команды епаblе и disable, что гораздо удобнее. 


#### 4. [[⬆]](#toc) <a name='recommended_sources'>Дополнительные источники</a>

1. [Systemd - Википедия](https://ru.wikipedia.org/wiki/Systemd)
2. [????????????????](https://www.alexgur.ru/articles/2275/)
3. [????????????????](https://losst.pro/nastrojka-zagruzchika-grub)
4. Весь Linux Для тех, кто хочет стать профессионалом, стр.324
